//
//  RealTimeAlertService.swift
//  Lopan
//
//  Created by Claude Code on 2025/8/16.
//

import Foundation
import SwiftUI
import Combine

// MARK: - Alert Types and Definitions (警报类型和定义)

/// Real-time alert severity levels
/// 实时警报严重程度等级
enum AlertSeverity: String, CaseIterable, Codable {
    case info = "info"
    case warning = "warning"
    case error = "error"
    case critical = "critical"
    case emergency = "emergency"
    
    var displayName: String {
        switch self {
        case .info: return "信息"
        case .warning: return "警告"
        case .error: return "错误"
        case .critical: return "严重"
        case .emergency: return "紧急"
        }
    }
    
    var color: Color {
        switch self {
        case .info: return LopanColors.primary
        case .warning: return LopanColors.warning
        case .error: return LopanColors.error
        case .critical: return LopanColors.primary
        case .emergency: return LopanColors.textPrimary
        }
    }
    
    var responseTimeThreshold: TimeInterval {
        switch self {
        case .info: return 3600 // 1 hour
        case .warning: return 1800 // 30 minutes
        case .error: return 900 // 15 minutes
        case .critical: return 300 // 5 minutes
        case .emergency: return 60 // 1 minute
        }
    }
}

/// Alert source systems
/// 警报源系统
enum AlertSource: String, CaseIterable, Codable {
    case machine = "machine"
    case production = "production"
    case quality = "quality"
    case system = "system"
    case security = "security"
    case maintenance = "maintenance"
    case user = "user"
    case external = "external"
    
    var displayName: String {
        switch self {
        case .machine: return "机台系统"
        case .production: return "生产系统"
        case .quality: return "质量系统"
        case .system: return "系统监控"
        case .security: return "安全系统"
        case .maintenance: return "维护系统"
        case .user: return "用户操作"
        case .external: return "外部系统"
        }
    }
    
    var icon: String {
        switch self {
        case .machine: return "gear"
        case .production: return "factory"
        case .quality: return "checkmark.seal"
        case .system: return "server.rack"
        case .security: return "shield"
        case .maintenance: return "wrench"
        case .user: return "person"
        case .external: return "network"
        }
    }
}

/// Alert status tracking
/// 警报状态跟踪
enum AlertStatus: String, CaseIterable, Codable {
    case active = "active"
    case acknowledged = "acknowledged"
    case investigating = "investigating"
    case resolved = "resolved"
    case suppressed = "suppressed"
    case escalated = "escalated"
    
    var displayName: String {
        switch self {
        case .active: return "活跃"
        case .acknowledged: return "已确认"
        case .investigating: return "调查中"
        case .resolved: return "已解决"
        case .suppressed: return "已抑制"
        case .escalated: return "已上报"
        }
    }
    
    var color: Color {
        switch self {
        case .active: return LopanColors.error
        case .acknowledged: return LopanColors.warning
        case .investigating: return LopanColors.primary
        case .resolved: return LopanColors.success
        case .suppressed: return LopanColors.textSecondary
        case .escalated: return LopanColors.primary
        }
    }
}

// MARK: - Alert Data Models (警报数据模型)

/// Core real-time alert structure
/// 核心实时警报结构
struct RealTimeAlert: Identifiable, Codable, Hashable {
    let id: String
    let timestamp: Date
    let source: AlertSource
    let severity: AlertSeverity
    let status: AlertStatus
    let title: String
    let description: String
    let details: [String: String]
    let affectedEntities: [String]
    let triggerConditions: [String]
    let recommendedActions: [String]
    let assignedTo: String?
    let acknowledgedBy: String?
    let acknowledgedAt: Date?
    let resolvedBy: String?
    let resolvedAt: Date?
    let escalationLevel: Int
    let parentAlertId: String?
    let childAlertIds: [String]
    let correlationId: String?
    let suppressionRules: [String]
    let isAutoGenerated: Bool
    let metadata: [String: String]
    
    init(
        source: AlertSource,
        severity: AlertSeverity,
        title: String,
        description: String,
        details: [String: String] = [:],
        affectedEntities: [String] = [],
        triggerConditions: [String] = [],
        recommendedActions: [String] = [],
        assignedTo: String? = nil,
        correlationId: String? = nil,
        isAutoGenerated: Bool = true,
        metadata: [String: String] = [:]
    ) {
        self.id = UUID().uuidString
        self.timestamp = Date()
        self.source = source
        self.severity = severity
        self.status = .active
        self.title = title
        self.description = description
        self.details = details
        self.affectedEntities = affectedEntities
        self.triggerConditions = triggerConditions
        self.recommendedActions = recommendedActions
        self.assignedTo = assignedTo
        self.acknowledgedBy = nil
        self.acknowledgedAt = nil
        self.resolvedBy = nil
        self.resolvedAt = nil
        self.escalationLevel = 0
        self.parentAlertId = nil
        self.childAlertIds = []
        self.correlationId = correlationId
        self.suppressionRules = []
        self.isAutoGenerated = isAutoGenerated
        self.metadata = metadata
    }
}

/// Alert rule definition for automated monitoring
/// 用于自动监控的警报规则定义
struct AlertRule: Identifiable, Codable {
    let id: String
    let name: String
    let description: String
    let isActive: Bool
    let source: AlertSource
    let severity: AlertSeverity
    let conditions: [AlertCondition]
    let actions: [AlertAction]
    let suppressionDuration: TimeInterval?
    let escalationChain: [EscalationStep]
    let applicableRoles: [UserRole]
    let scheduledActive: Bool
    let activeSchedule: AlertSchedule?
    let lastTriggered: Date?
    let triggerCount: Int
    let createdBy: String
    let createdAt: Date
    
    init(
        name: String,
        description: String,
        source: AlertSource,
        severity: AlertSeverity,
        conditions: [AlertCondition],
        actions: [AlertAction] = [],
        suppressionDuration: TimeInterval? = nil,
        escalationChain: [EscalationStep] = [],
        applicableRoles: [UserRole] = [],
        createdBy: String
    ) {
        self.id = UUID().uuidString
        self.name = name
        self.description = description
        self.isActive = true
        self.source = source
        self.severity = severity
        self.conditions = conditions
        self.actions = actions
        self.suppressionDuration = suppressionDuration
        self.escalationChain = escalationChain
        self.applicableRoles = applicableRoles
        self.scheduledActive = false
        self.activeSchedule = nil
        self.lastTriggered = nil
        self.triggerCount = 0
        self.createdBy = createdBy
        self.createdAt = Date()
    }
}

/// Alert condition for rule evaluation
/// 用于规则评估的警报条件
struct AlertCondition: Codable {
    let id: String
    let type: ConditionType
    let field: String
    let comparisonOperator: ComparisonOperator
    let value: String
    let aggregationType: AggregationType?
    let timeWindow: TimeInterval?
    
    enum ConditionType: String, Codable {
        case threshold = "threshold"
        case change = "change"
        case anomaly = "anomaly"
        case pattern = "pattern"
        case count = "count"
    }
    
    enum ComparisonOperator: String, Codable {
        case equals = "equals"
        case notEquals = "not_equals"
        case greaterThan = "greater_than"
        case lessThan = "less_than"
        case greaterThanOrEqual = "greater_than_or_equal"
        case lessThanOrEqual = "less_than_or_equal"
        case contains = "contains"
        case notContains = "not_contains"
        case matches = "matches"
    }
    
    enum AggregationType: String, Codable {
        case sum = "sum"
        case average = "average"
        case count = "count"
        case maximum = "maximum"
        case minimum = "minimum"
    }
}

/// Alert action to be taken when rule triggers
/// 规则触发时要采取的警报操作
struct AlertAction: Codable {
    let id: String
    let type: ActionType
    let parameters: [String: String]
    let isEnabled: Bool
    
    enum ActionType: String, Codable {
        case notification = "notification"
        case webhook = "webhook"
        case email = "email"
        case sms = "sms"
        case script = "script"
        case escalation = "escalation"
        case suppression = "suppression"
    }
}

/// Escalation step in alert escalation chain
/// 警报升级链中的升级步骤
struct EscalationStep: Codable {
    let level: Int
    let delayMinutes: Int
    let targetUsers: [String]
    let targetRoles: [UserRole]
    let actions: [AlertAction]
    let conditions: [String] // Conditions that must be met to proceed to this step
}

/// Alert schedule for rule activation
/// 规则激活的警报计划
struct AlertSchedule: Codable {
    let daysOfWeek: [Int] // 0 = Sunday, 1 = Monday, etc.
    let startTime: String // "HH:mm" format
    let endTime: String // "HH:mm" format
    let timezone: String
    let exceptions: [Date] // Dates when the schedule is not active
}

// MARK: - Alert Correlation and Grouping (警报关联和分组)

/// Alert correlation engine for reducing noise
/// 用于减少噪音的警报关联引擎
class AlertCorrelationEngine {
    
    /// Correlate new alert with existing alerts
    /// 将新警报与现有警报关联
    static func correlateAlert(_ newAlert: RealTimeAlert, with existingAlerts: [RealTimeAlert]) -> CorrelationResult {
        var correlatedAlerts: [RealTimeAlert] = []
        var correlationReason: String = ""
        var shouldSuppressNew = false
        
        // Time-based correlation (alerts within 5 minutes)
        let timeWindow: TimeInterval = 300
        let recentAlerts = existingAlerts.filter { alert in
            newAlert.timestamp.timeIntervalSince(alert.timestamp) <= timeWindow &&
            alert.status == .active
        }
        
        // Entity-based correlation
        for alert in recentAlerts {
            let commonEntities = Set(newAlert.affectedEntities).intersection(Set(alert.affectedEntities))
            if !commonEntities.isEmpty {
                correlatedAlerts.append(alert)
                correlationReason = "共同受影响实体: \(commonEntities.joined(separator: ", "))"
            }
        }
        
        // Source and severity correlation
        let sameSeverityAlerts = recentAlerts.filter { alert in
            alert.source == newAlert.source && alert.severity == newAlert.severity
        }
        
        if sameSeverityAlerts.count >= 3 {
            correlatedAlerts.append(contentsOf: sameSeverityAlerts)
            correlationReason = "相同源和严重程度的多个警报"
            shouldSuppressNew = true // Suppress if too many similar alerts
        }
        
        // Pattern-based correlation
        let patternAlerts = recentAlerts.filter { alert in
            alert.title.contains(newAlert.title.prefix(10)) || // Similar titles
            !Set(alert.triggerConditions).intersection(Set(newAlert.triggerConditions)).isEmpty // Similar conditions
        }
        
        if !patternAlerts.isEmpty {
            correlatedAlerts.append(contentsOf: patternAlerts)
            if correlationReason.isEmpty {
                correlationReason = "相似的警报模式"
            }
        }
        
        return CorrelationResult(
            correlatedAlerts: Array(Set(correlatedAlerts)), // Remove duplicates
            correlationReason: correlationReason,
            shouldSuppressNew: shouldSuppressNew,
            recommendedParentAlert: correlatedAlerts.first { $0.severity.rawValue >= newAlert.severity.rawValue }
        )
    }
    
    /// Group alerts by correlation
    /// 按关联分组警报
    static func groupAlerts(_ alerts: [RealTimeAlert]) -> [AlertGroup] {
        var groups: [AlertGroup] = []
        var processedAlerts = Set<String>()
        
        for alert in alerts {
            if processedAlerts.contains(alert.id) { continue }
            
            let correlationResult = correlateAlert(alert, with: alerts)
            let groupAlerts = [alert] + correlationResult.correlatedAlerts
            
            let group = AlertGroup(
                id: UUID().uuidString,
                alerts: groupAlerts,
                primaryAlert: alert,
                correlationReason: correlationResult.correlationReason,
                createdAt: Date()
            )
            
            groups.append(group)
            
            // Mark all alerts in this group as processed
            for groupAlert in groupAlerts {
                processedAlerts.insert(groupAlert.id)
            }
        }
        
        return groups.sorted { $0.primaryAlert.severity.rawValue > $1.primaryAlert.severity.rawValue }
    }
}

/// Result of alert correlation
/// 警报关联的结果
struct CorrelationResult {
    let correlatedAlerts: [RealTimeAlert]
    let correlationReason: String
    let shouldSuppressNew: Bool
    let recommendedParentAlert: RealTimeAlert?
}

/// Group of correlated alerts
/// 关联警报组
struct AlertGroup: Identifiable {
    let id: String
    let alerts: [RealTimeAlert]
    let primaryAlert: RealTimeAlert
    let correlationReason: String
    let createdAt: Date
    
    var totalCount: Int { alerts.count }
    var highestSeverity: AlertSeverity { 
        alerts.map { $0.severity }.max { a, b in
            AlertSeverity.allCases.firstIndex(of: a)! < AlertSeverity.allCases.firstIndex(of: b)!
        } ?? .info
    }
}

// MARK: - Real-Time Alert Service (实时警报服务)

/// Main service for real-time alert monitoring and management
/// 实时警报监控和管理的主要服务
@MainActor
public class RealTimeAlertService: ObservableObject {
    
    // MARK: - Dependencies
    private let notificationEngine: NotificationEngine
    private let auditService: NewAuditingService
    private let authService: AuthenticationService
    private let machineRepository: MachineRepository
    private let productionBatchRepository: ProductionBatchRepository
    
    // MARK: - State Management
    @Published var activeAlerts: [RealTimeAlert] = []
    @Published var alertGroups: [AlertGroup] = []
    @Published var alertRules: [AlertRule] = []
    @Published var suppressedAlerts: [RealTimeAlert] = []
    @Published var isMonitoring = false
    @Published var alertStats: AlertStatistics = AlertStatistics()
    
    // MARK: - Configuration
    private let monitoringInterval: TimeInterval = 10.0 // 10 seconds
    private let maxActiveAlerts = 500
    private let alertRetentionDays = 30
    private var monitoringTimer: Timer?
    private var alertSubjects: [AlertSource: PassthroughSubject<RealTimeAlert, Never>] = [:]
    
    init(
        notificationEngine: NotificationEngine,
        auditService: NewAuditingService,
        authService: AuthenticationService,
        machineRepository: MachineRepository,
        productionBatchRepository: ProductionBatchRepository
    ) {
        self.notificationEngine = notificationEngine
        self.auditService = auditService
        self.authService = authService
        self.machineRepository = machineRepository
        self.productionBatchRepository = productionBatchRepository
        
        setupDefaultAlertRules()
        setupAlertSubjects()
    }
    
    // MARK: - Service Lifecycle
    
    /// Start real-time alert monitoring
    /// 启动实时警报监控
    func startMonitoring() {
        guard !isMonitoring else { return }
        
        isMonitoring = true
        
        // Start periodic monitoring
        monitoringTimer = Timer.scheduledTimer(withTimeInterval: monitoringInterval, repeats: true) { [weak self] _ in
            Task { @MainActor in
                await self?.performMonitoringCycle()
            }
        }
        
        // Perform initial monitoring cycle
        Task {
            await performMonitoringCycle()
        }
        
        Task {
            try? await auditService.logSecurityEvent(
                event: "alert_monitoring_started",
                userId: authService.currentUser?.id ?? "system",
                details: ["monitoring_interval": "\(monitoringInterval)"]
            )
        }
    }
    
    /// Stop real-time alert monitoring
    /// 停止实时警报监控
    func stopMonitoring() {
        monitoringTimer?.invalidate()
        monitoringTimer = nil
        isMonitoring = false
        
        Task {
            try? await auditService.logSecurityEvent(
                event: "alert_monitoring_stopped",
                userId: authService.currentUser?.id ?? "system",
                details: [:]
            )
        }
    }
    
    // MARK: - Alert Generation and Management
    
    /// Create and process new alert
    /// 创建和处理新警报
    func createAlert(
        source: AlertSource,
        severity: AlertSeverity,
        title: String,
        description: String,
        details: [String: String] = [:],
        affectedEntities: [String] = [],
        triggerConditions: [String] = [],
        recommendedActions: [String] = []
    ) async throws {
        
        let alert = RealTimeAlert(
            source: source,
            severity: severity,
            title: title,
            description: description,
            details: details,
            affectedEntities: affectedEntities,
            triggerConditions: triggerConditions,
            recommendedActions: recommendedActions,
            correlationId: UUID().uuidString,
            isAutoGenerated: false
        )
        
        try await processNewAlert(alert)
    }
    
    /// Process new alert through correlation and notification
    /// 通过关联和通知处理新警报
    private func processNewAlert(_ alert: RealTimeAlert) async throws {
        // Correlate with existing alerts
        let correlationResult = AlertCorrelationEngine.correlateAlert(alert, with: activeAlerts)
        
        // Check if alert should be suppressed
        if correlationResult.shouldSuppressNew {
            suppressedAlerts.append(alert)
            alertStats.recordSuppression(severity: alert.severity)
            return
        }
        
        // Add to active alerts
        activeAlerts.insert(alert, at: 0)
        if activeAlerts.count > maxActiveAlerts {
            activeAlerts.removeLast()
        }
        
        // Update alert groups
        alertGroups = AlertCorrelationEngine.groupAlerts(activeAlerts)
        
        // Update statistics
        alertStats.recordAlert(source: alert.source, severity: alert.severity)
        
        // Send notifications based on severity and routing rules
        try await sendAlertNotifications(alert)
        
        // Trigger alert subject for real-time updates
        alertSubjects[alert.source]?.send(alert)
        
        // Auto-assign based on rules
        await autoAssignAlert(alert)
        
        // Start escalation timer if needed
        if alert.severity == .critical || alert.severity == .emergency {
            await scheduleEscalation(alert)
        }
        
        // Log alert creation
        try? await auditService.logSecurityEvent(
            event: "alert_created",
            userId: authService.currentUser?.id ?? "system",
            details: [
                "alert_id": alert.id,
                "source": alert.source.rawValue,
                "severity": alert.severity.rawValue,
                "affected_entities": alert.affectedEntities.joined(separator: ","),
                "correlation_id": alert.correlationId ?? ""
            ]
        )
    }
    
    /// Send notifications for alert
    /// 为警报发送通知
    private func sendAlertNotifications(_ alert: RealTimeAlert) async throws {
        let templateId: String
        
        switch alert.source {
        case .machine:
            templateId = "machine_error"
        case .production:
            templateId = "batch_completed"
        case .quality:
            templateId = "quality_issue"
        case .security:
            templateId = "security_alert"
        case .system:
            templateId = "system_health"
        case .maintenance:
            templateId = "maintenance_due"
        default:
            templateId = "system_health" // Default template
        }
        
        let parameters = [
            "alertTitle": alert.title,
            "alertDescription": alert.description,
            "severity": alert.severity.displayName,
            "source": alert.source.displayName,
            "affectedEntities": alert.affectedEntities.joined(separator: ", ")
        ]
        
        // Determine notification channels based on severity
        let channels: [NotificationChannel] = {
            switch alert.severity {
            case .emergency:
                return [.inApp, .push, .sms, .dashboard]
            case .critical:
                return [.inApp, .push, .dashboard]
            case .error:
                return [.inApp, .dashboard]
            case .warning:
                return [.inApp, .dashboard]
            case .info:
                return [.dashboard]
            }
        }()
        
        try await notificationEngine.sendNotification(
            templateId: templateId,
            parameters: parameters,
            customChannels: channels,
            relatedEntityId: alert.id,
            relatedEntityType: "alert"
        )
    }
    
    // MARK: - Alert Status Management
    
    /// Acknowledge alert
    /// 确认警报
    func acknowledgeAlert(_ alertId: String, userId: String, comment: String = "") async throws {
        guard let index = activeAlerts.firstIndex(where: { $0.id == alertId }) else {
            throw AlertError.alertNotFound(alertId)
        }
        
        // Create acknowledged alert
        var acknowledgedAlert = activeAlerts[index]
        acknowledgedAlert = RealTimeAlert(
            source: acknowledgedAlert.source,
            severity: acknowledgedAlert.severity,
            title: acknowledgedAlert.title,
            description: acknowledgedAlert.description,
            details: acknowledgedAlert.details,
            affectedEntities: acknowledgedAlert.affectedEntities,
            triggerConditions: acknowledgedAlert.triggerConditions,
            recommendedActions: acknowledgedAlert.recommendedActions
        )
        
        activeAlerts[index] = acknowledgedAlert
        
        // Update statistics
        alertStats.recordAcknowledgment(severity: acknowledgedAlert.severity)
        
        // Send notification
        try await notificationEngine.sendImmediateNotification(
            title: "警报已确认",
            body: "警报 '\(acknowledgedAlert.title)' 已被 \(userId) 确认",
            category: .system,
            priority: .medium
        )
        
        // Log acknowledgment
        try? await auditService.logSecurityEvent(
            event: "alert_acknowledged",
            userId: userId,
            details: [
                "alert_id": alertId,
                "comment": comment
            ]
        )
    }
    
    /// Resolve alert
    /// 解决警报
    func resolveAlert(_ alertId: String, userId: String, resolution: String) async throws {
        guard let index = activeAlerts.firstIndex(where: { $0.id == alertId }) else {
            throw AlertError.alertNotFound(alertId)
        }
        
        let resolvedAlert = activeAlerts[index]
        activeAlerts.remove(at: index)
        
        // Update statistics
        alertStats.recordResolution(
            severity: resolvedAlert.severity,
            resolutionTime: Date().timeIntervalSince(resolvedAlert.timestamp)
        )
        
        // Send notification
        try await notificationEngine.sendImmediateNotification(
            title: "警报已解决",
            body: "警报 '\(resolvedAlert.title)' 已被解决: \(resolution)",
            category: .system,
            priority: .medium
        )
        
        // Log resolution
        try? await auditService.logSecurityEvent(
            event: "alert_resolved",
            userId: userId,
            details: [
                "alert_id": alertId,
                "resolution": resolution,
                "resolution_time_minutes": "\(Int(Date().timeIntervalSince(resolvedAlert.timestamp) / 60))"
            ]
        )
    }
    
    /// Escalate alert
    /// 升级警报
    func escalateAlert(_ alertId: String, toLevel: Int, reason: String) async throws {
        guard let index = activeAlerts.firstIndex(where: { $0.id == alertId }) else {
            throw AlertError.alertNotFound(alertId)
        }
        
        let alert = activeAlerts[index]
        
        // Create escalation
        try await notificationEngine.sendImmediateNotification(
            title: "警报升级",
            body: "警报 '\(alert.title)' 已升级到等级 \(toLevel): \(reason)",
            category: .system,
            priority: .urgent
        )
        
        // Update statistics
        alertStats.recordEscalation(severity: alert.severity)
        
        // Log escalation
        try? await auditService.logSecurityEvent(
            event: "alert_escalated",
            userId: authService.currentUser?.id ?? "system",
            details: [
                "alert_id": alertId,
                "escalation_level": "\(toLevel)",
                "reason": reason
            ]
        )
    }
    
    // MARK: - Alert Rules Management
    
    /// Add new alert rule
    /// 添加新警报规则
    func addAlertRule(_ rule: AlertRule) async {
        alertRules.append(rule)
        
        try? await auditService.logSecurityEvent(
            event: "alert_rule_created",
            userId: authService.currentUser?.id ?? "system",
            details: [
                "rule_id": rule.id,
                "rule_name": rule.name,
                "source": rule.source.rawValue,
                "severity": rule.severity.rawValue
            ]
        )
    }
    
    /// Remove alert rule
    /// 删除警报规则
    func removeAlertRule(_ ruleId: String) async {
        alertRules.removeAll { $0.id == ruleId }
        
        try? await auditService.logSecurityEvent(
            event: "alert_rule_deleted",
            userId: authService.currentUser?.id ?? "system",
            details: ["rule_id": ruleId]
        )
    }
    
    /// Evaluate alert rules against current system state
    /// 根据当前系统状态评估警报规则
    private func evaluateAlertRules() async {
        for rule in alertRules where rule.isActive {
            do {
                let shouldTrigger = try await evaluateRule(rule)
                if shouldTrigger {
                    try await triggerRule(rule)
                }
            } catch {
                try? await auditService.logSecurityEvent(
                    event: "alert_rule_evaluation_failed",
                    userId: "system",
                    details: [
                        "rule_id": rule.id,
                        "error": error.localizedDescription
                    ]
                )
            }
        }
    }
    
    /// Evaluate individual rule
    /// 评估单个规则
    private func evaluateRule(_ rule: AlertRule) async throws -> Bool {
        // This is a simplified evaluation - in a real system, this would
        // connect to various data sources and evaluate complex conditions
        
        switch rule.source {
        case .machine:
            return try await evaluateMachineRule(rule)
        case .production:
            return try await evaluateProductionRule(rule)
        case .system:
            return try await evaluateSystemRule(rule)
        default:
            return false
        }
    }
    
    /// Evaluate machine-specific rules
    /// 评估机台特定规则
    private func evaluateMachineRule(_ rule: AlertRule) async throws -> Bool {
        let machines = try await machineRepository.fetchAllMachines()
        
        for condition in rule.conditions {
            switch condition.field {
            case "status":
                let errorMachines = machines.filter { !$0.isActive || $0.status != .running }
                if !errorMachines.isEmpty {
                    return true
                }
            case "temperature":
                // Simulated temperature check
                let overheatedMachines = machines.filter { _ in Double.random(in: 0...100) > 80 }
                if !overheatedMachines.isEmpty {
                    return true
                }
            default:
                break
            }
        }
        
        return false
    }
    
    /// Evaluate production-specific rules
    /// 评估生产特定规则
    private func evaluateProductionRule(_ rule: AlertRule) async throws -> Bool {
        let activeBatches = try await productionBatchRepository.fetchActiveBatches()
        
        for condition in rule.conditions {
            switch condition.field {
            case "batch_duration":
                // Check for long-running batches
                let longRunningBatches = activeBatches.filter { batch in
                    if let startTime = batch.executionTime {
                        return Date().timeIntervalSince(startTime) > 14400 // 4 hours
                    }
                    return false
                }
                if !longRunningBatches.isEmpty {
                    return true
                }
            case "batch_count":
                // Check for too many active batches
                if activeBatches.count > 20 {
                    return true
                }
            default:
                break
            }
        }
        
        return false
    }
    
    /// Evaluate system-specific rules
    /// 评估系统特定规则
    private func evaluateSystemRule(_ rule: AlertRule) async throws -> Bool {
        // Simulated system checks
        for condition in rule.conditions {
            switch condition.field {
            case "memory_usage":
                // Simulated memory check
                if Double.random(in: 0...100) > 90 {
                    return true
                }
            case "cpu_usage":
                // Simulated CPU check
                if Double.random(in: 0...100) > 85 {
                    return true
                }
            default:
                break
            }
        }
        
        return false
    }
    
    /// Trigger alert rule
    /// 触发警报规则
    private func triggerRule(_ rule: AlertRule) async throws {
        let alert = RealTimeAlert(
            source: rule.source,
            severity: rule.severity,
            title: "规则触发: \(rule.name)",
            description: rule.description,
            triggerConditions: rule.conditions.map { "\($0.field) \($0.comparisonOperator.rawValue) \($0.value)" },
            recommendedActions: ["检查规则条件", "验证系统状态", "采取纠正措施"],
            correlationId: rule.id,
            isAutoGenerated: true
        )
        
        try await processNewAlert(alert)
    }
    
    // MARK: - Monitoring Operations
    
    /// Perform monitoring cycle
    /// 执行监控周期
    private func performMonitoringCycle() async {
        // Evaluate alert rules
        await evaluateAlertRules()
        
        // Clean up old alerts
        await cleanupOldAlerts()
        
        // Update alert groups
        alertGroups = AlertCorrelationEngine.groupAlerts(activeAlerts)
        
        // Update statistics
        updateStatistics()
    }
    
    /// Auto-assign alert based on rules
    /// 根据规则自动分配警报
    private func autoAssignAlert(_ alert: RealTimeAlert) async {
        // Simple auto-assignment logic based on source and severity
        // In a real system, this would use more sophisticated routing rules
        
        let targetRole: UserRole? = {
            switch alert.source {
            case .machine, .maintenance:
                return .workshopTechnician
            case .production:
                return .workshopManager
            case .quality:
                return .workshopManager
            case .security, .system:
                return .administrator
            default:
                return nil
            }
        }()
        
        if let role = targetRole {
            try? await auditService.logSecurityEvent(
                event: "alert_auto_assigned",
                userId: "system",
                details: [
                    "alert_id": alert.id,
                    "assigned_role": role.rawValue
                ]
            )
        }
    }
    
    /// Schedule escalation for critical alerts
    /// 为严重警报安排升级
    private func scheduleEscalation(_ alert: RealTimeAlert) async {
        let escalationDelay = alert.severity.responseTimeThreshold
        
        Task {
            try? await Task.sleep(nanoseconds: UInt64(escalationDelay * 1_000_000_000))
            
            // Check if alert is still active and unacknowledged
            if activeAlerts.contains(where: { $0.id == alert.id && $0.status == .active }) {
                try? await escalateAlert(alert.id, toLevel: 1, reason: "响应时间超时")
            }
        }
    }
    
    /// Clean up old alerts
    /// 清理旧警报
    private func cleanupOldAlerts() async {
        let cutoffDate = Date().addingTimeInterval(-TimeInterval(alertRetentionDays * 24 * 3600))
        
        let initialCount = activeAlerts.count
        activeAlerts.removeAll { $0.timestamp < cutoffDate }
        suppressedAlerts.removeAll { $0.timestamp < cutoffDate }
        
        let removedCount = initialCount - activeAlerts.count
        if removedCount > 0 {
            alertStats.recordCleanup(removedCount: removedCount)
        }
    }
    
    /// Update alert statistics
    /// 更新警报统计
    private func updateStatistics() {
        alertStats.currentActiveCount = activeAlerts.count
        alertStats.currentSuppressedCount = suppressedAlerts.count
    }
    
    // MARK: - Setup and Configuration
    
    /// Setup default alert rules
    /// 设置默认警报规则
    private func setupDefaultAlertRules() {
        // Default machine alert rule
        let machineRule = AlertRule(
            name: "机台状态监控",
            description: "监控机台运行状态和错误",
            source: .machine,
            severity: .error,
            conditions: [
                AlertCondition(
                    id: UUID().uuidString,
                    type: .threshold,
                    field: "status",
                    comparisonOperator: .notEquals,
                    value: "running",
                    aggregationType: nil,
                    timeWindow: nil
                )
            ],
            createdBy: "system"
        )
        
        // Default production alert rule
        let productionRule = AlertRule(
            name: "生产批次监控",
            description: "监控生产批次异常情况",
            source: .production,
            severity: .warning,
            conditions: [
                AlertCondition(
                    id: UUID().uuidString,
                    type: .threshold,
                    field: "batch_duration",
                    comparisonOperator: .greaterThan,
                    value: "14400", // 4 hours in seconds
                    aggregationType: nil,
                    timeWindow: nil
                )
            ],
            createdBy: "system"
        )
        
        alertRules = [machineRule, productionRule]
    }
    
    /// Setup alert subjects for real-time updates
    /// 设置用于实时更新的警报主题
    private func setupAlertSubjects() {
        for source in AlertSource.allCases {
            alertSubjects[source] = PassthroughSubject<RealTimeAlert, Never>()
        }
    }
    
    /// Get alert subject for specific source
    /// 获取特定源的警报主题
    func getAlertSubject(for source: AlertSource) -> PassthroughSubject<RealTimeAlert, Never>? {
        return alertSubjects[source]
    }
    
    deinit {
        monitoringTimer?.invalidate()
        monitoringTimer = nil
    }
}

// MARK: - Alert Statistics (警报统计)

/// Statistics tracking for alert system
/// 警报系统的统计跟踪
struct AlertStatistics {
    private var alertsBySource: [AlertSource: Int] = [:]
    private var alertsBySeverity: [AlertSeverity: Int] = [:]
    private var acknowledgmentsByseverity: [AlertSeverity: Int] = [:]
    private var resolutionsBySevenity: [AlertSeverity: Int] = [:]
    private var escalationsBySeverity: [AlertSeverity: Int] = [:]
    private var suppressionsBySeverity: [AlertSeverity: Int] = [:]
    private var resolutionTimes: [AlertSeverity: [TimeInterval]] = [:]
    
    var currentActiveCount = 0
    var currentSuppressedCount = 0
    var totalCleanupsPerformed = 0
    
    mutating func recordAlert(source: AlertSource, severity: AlertSeverity) {
        alertsBySource[source, default: 0] += 1
        alertsBySeverity[severity, default: 0] += 1
    }
    
    mutating func recordAcknowledgment(severity: AlertSeverity) {
        acknowledgmentsByseverity[severity, default: 0] += 1
    }
    
    mutating func recordResolution(severity: AlertSeverity, resolutionTime: TimeInterval) {
        resolutionsBySevenity[severity, default: 0] += 1
        resolutionTimes[severity, default: []].append(resolutionTime)
    }
    
    mutating func recordEscalation(severity: AlertSeverity) {
        escalationsBySeverity[severity, default: 0] += 1
    }
    
    mutating func recordSuppression(severity: AlertSeverity) {
        suppressionsBySeverity[severity, default: 0] += 1
    }
    
    mutating func recordCleanup(removedCount: Int) {
        totalCleanupsPerformed += removedCount
    }
    
    func getTotalAlerts() -> Int {
        return alertsBySeverity.values.reduce(0, +)
    }
    
    func getAverageResolutionTime(for severity: AlertSeverity) -> TimeInterval? {
        guard let times = resolutionTimes[severity], !times.isEmpty else { return nil }
        return times.reduce(0, +) / Double(times.count)
    }
    
    func getAcknowledgmentRate(for severity: AlertSeverity) -> Double {
        let total = alertsBySeverity[severity, default: 0]
        let acknowledged = acknowledgmentsByseverity[severity, default: 0]
        return total > 0 ? Double(acknowledged) / Double(total) : 0.0
    }
}

// MARK: - Error Types (错误类型)

enum AlertError: LocalizedError {
    case alertNotFound(String)
    case ruleEvaluationFailed(String)
    case invalidCondition(String)
    case escalationFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .alertNotFound(let alertId):
            return "Alert with ID '\(alertId)' not found"
        case .ruleEvaluationFailed(let ruleId):
            return "Failed to evaluate alert rule '\(ruleId)'"
        case .invalidCondition(let condition):
            return "Invalid alert condition: \(condition)"
        case .escalationFailed(let reason):
            return "Alert escalation failed: \(reason)"
        }
    }
}